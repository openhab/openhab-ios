// Copyright (c) 2010-2024 Contributors to the openHAB project
//
// See the NOTICE file(s) distributed with this work for additional
// information.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0
//
// SPDX-License-Identifier: EPL-2.0

// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
@preconcurrency import struct Foundation.URL
#else
import struct Foundation.Data
import struct Foundation.Date
import struct Foundation.URL
#endif
import HTTPTypes

public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(serverURL: Foundation.URL,
                configuration: Configuration = .init(),
                transport: any ClientTransport,
                middlewares: [any ClientMiddleware] = []) {
        client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }

    private var converter: Converter {
        client.converter
    }

    /// Adds a new member to a group item.
    ///
    /// - Remark: HTTP `PUT /items/{itemName}/members/{memberItemName}`.
    /// - Remark: Generated from `#/paths//items/{itemName}/members/{memberItemName}/put(addMemberToGroupItem)`.
    public func addMemberToGroupItem(_ input: Operations.addMemberToGroupItem.Input) async throws -> Operations.addMemberToGroupItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addMemberToGroupItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/members/{}",
                    parameters: [
                        input.path.itemName,
                        input.path.memberItemName
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 404:
                    .notFound(.init())
                case 405:
                    .methodNotAllowed(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Removes an existing member from a group item.
    ///
    /// - Remark: HTTP `DELETE /items/{itemName}/members/{memberItemName}`.
    /// - Remark: Generated from `#/paths//items/{itemName}/members/{memberItemName}/delete(removeMemberFromGroupItem)`.
    public func removeMemberFromGroupItem(_ input: Operations.removeMemberFromGroupItem.Input) async throws -> Operations.removeMemberFromGroupItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.removeMemberFromGroupItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/members/{}",
                    parameters: [
                        input.path.itemName,
                        input.path.memberItemName
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 404:
                    .notFound(.init())
                case 405:
                    .methodNotAllowed(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Adds metadata to an item.
    ///
    /// - Remark: HTTP `PUT /items/{itemname}/metadata/{namespace}`.
    /// - Remark: Generated from `#/paths//items/{itemname}/metadata/{namespace}/put(addMetadataToItem)`.
    public func addMetadataToItem(_ input: Operations.addMetadataToItem.Input) async throws -> Operations.addMetadataToItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addMetadataToItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/metadata/{}",
                    parameters: [
                        input.path.itemname,
                        input.path.namespace
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 201:
                    .created(.init())
                case 400:
                    .badRequest(.init())
                case 404:
                    .notFound(.init())
                case 405:
                    .methodNotAllowed(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Removes metadata from an item.
    ///
    /// - Remark: HTTP `DELETE /items/{itemname}/metadata/{namespace}`.
    /// - Remark: Generated from `#/paths//items/{itemname}/metadata/{namespace}/delete(removeMetadataFromItem)`.
    public func removeMetadataFromItem(_ input: Operations.removeMetadataFromItem.Input) async throws -> Operations.removeMetadataFromItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.removeMetadataFromItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/metadata/{}",
                    parameters: [
                        input.path.itemname,
                        input.path.namespace
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 404:
                    .notFound(.init())
                case 405:
                    .methodNotAllowed(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Adds a tag to an item.
    ///
    /// - Remark: HTTP `PUT /items/{itemname}/tags/{tag}`.
    /// - Remark: Generated from `#/paths//items/{itemname}/tags/{tag}/put(addTagToItem)`.
    public func addTagToItem(_ input: Operations.addTagToItem.Input) async throws -> Operations.addTagToItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addTagToItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/tags/{}",
                    parameters: [
                        input.path.itemname,
                        input.path.tag
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 404:
                    .notFound(.init())
                case 405:
                    .methodNotAllowed(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Removes a tag from an item.
    ///
    /// - Remark: HTTP `DELETE /items/{itemname}/tags/{tag}`.
    /// - Remark: Generated from `#/paths//items/{itemname}/tags/{tag}/delete(removeTagFromItem)`.
    public func removeTagFromItem(_ input: Operations.removeTagFromItem.Input) async throws -> Operations.removeTagFromItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.removeTagFromItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/tags/{}",
                    parameters: [
                        input.path.itemname,
                        input.path.tag
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 404:
                    .notFound(.init())
                case 405:
                    .methodNotAllowed(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Gets a single item.
    ///
    /// - Remark: HTTP `GET /items/{itemname}`.
    /// - Remark: Generated from `#/paths//items/{itemname}/get(getItemByName)`.
    public func getItemByName(_ input: Operations.getItemByName.Input) async throws -> Operations.getItemByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}",
                    parameters: [
                        input.path.itemname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "metadata",
                    value: input.query.metadata
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recursive",
                    value: input.query.recursive
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EnrichedItemDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Sends a command to an item.
    ///
    /// - Remark: HTTP `POST /items/{itemname}`.
    /// - Remark: Generated from `#/paths//items/{itemname}/post(sendItemCommand)`.
    public func sendItemCommand(_ input: Operations.sendItemCommand.Input) async throws -> Operations.sendItemCommand.Output {
        try await client.send(
            input: input,
            forOperation: Operations.sendItemCommand.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}",
                    parameters: [
                        input.path.itemname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .plainText(value):
                    try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 400:
                    .badRequest(.init())
                case 404:
                    .notFound(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Adds a new item to the registry or updates the existing item.
    ///
    /// - Remark: HTTP `PUT /items/{itemname}`.
    /// - Remark: Generated from `#/paths//items/{itemname}/put(addOrUpdateItemInRegistry)`.
    public func addOrUpdateItemInRegistry(_ input: Operations.addOrUpdateItemInRegistry.Input) async throws -> Operations.addOrUpdateItemInRegistry.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addOrUpdateItemInRegistry.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}",
                    parameters: [
                        input.path.itemname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.addOrUpdateItemInRegistry.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 201:
                    return .created(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                case 405:
                    return .methodNotAllowed(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Removes an item from the registry.
    ///
    /// - Remark: HTTP `DELETE /items/{itemname}`.
    /// - Remark: Generated from `#/paths//items/{itemname}/delete(removeItemFromRegistry)`.
    public func removeItemFromRegistry(_ input: Operations.removeItemFromRegistry.Input) async throws -> Operations.removeItemFromRegistry.Output {
        try await client.send(
            input: input,
            forOperation: Operations.removeItemFromRegistry.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}",
                    parameters: [
                        input.path.itemname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 404:
                    .notFound(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Get all available items.
    ///
    /// - Remark: HTTP `GET /items`.
    /// - Remark: Generated from `#/paths//items/get(getItems)`.
    public func getItems(_ input: Operations.getItems.Input) async throws -> Operations.getItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "type",
                    value: input.query._type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "metadata",
                    value: input.query.metadata
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recursive",
                    value: input.query.recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fields",
                    value: input.query.fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "staticDataOnly",
                    value: input.query.staticDataOnly
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.EnrichedItemDTO].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Adds a list of items to the registry or updates the existing items.
    ///
    /// - Remark: HTTP `PUT /items`.
    /// - Remark: Generated from `#/paths//items/put(addOrUpdateItemsInRegistry)`.
    public func addOrUpdateItemsInRegistry(_ input: Operations.addOrUpdateItemsInRegistry.Input) async throws -> Operations.addOrUpdateItemsInRegistry.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addOrUpdateItemsInRegistry.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .json(value):
                    try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.addOrUpdateItemsInRegistry.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "*/*"
                        ]
                    )
                    switch chosenContentType {
                    case "*/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .any(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Gets the state of an item.
    ///
    /// - Remark: HTTP `GET /items/{itemname}/state`.
    /// - Remark: Generated from `#/paths//items/{itemname}/state/get(getItemState_1)`.
    public func getItemState_1(_ input: Operations.getItemState_1.Input) async throws -> Operations.getItemState_1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemState_1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/state",
                    parameters: [
                        input.path.itemname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemState_1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/plain"
                        ]
                    )
                    switch chosenContentType {
                    case "text/plain":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .plainText(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Updates the state of an item.
    ///
    /// - Remark: HTTP `PUT /items/{itemname}/state`.
    /// - Remark: Generated from `#/paths//items/{itemname}/state/put(updateItemState)`.
    public func updateItemState(_ input: Operations.updateItemState.Input) async throws -> Operations.updateItemState.Output {
        try await client.send(
            input: input,
            forOperation: Operations.updateItemState.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/state",
                    parameters: [
                        input.path.itemname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case let .plainText(value):
                    try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/plain"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 202:
                    .accepted(.init())
                case 400:
                    .badRequest(.init())
                case 404:
                    .notFound(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Gets the namespace of an item.
    ///
    /// - Remark: HTTP `GET /items/{itemname}/metadata/namespaces`.
    /// - Remark: Generated from `#/paths//items/{itemname}/metadata/namespaces/get(getItemNamespaces)`.
    public func getItemNamespaces(_ input: Operations.getItemNamespaces.Input) async throws -> Operations.getItemNamespaces.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getItemNamespaces.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/metadata/namespaces",
                    parameters: [
                        input.path.itemname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemNamespaces.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Swift.String.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Gets the item which defines the requested semantics of an item.
    ///
    /// - Remark: HTTP `GET /items/{itemName}/semantic/{semanticClass}`.
    /// - Remark: Generated from `#/paths//items/{itemName}/semantic/{semanticClass}/get(getSemanticItem)`.
    public func getSemanticItem(_ input: Operations.getSemanticItem.Input) async throws -> Operations.getSemanticItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSemanticItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/items/{}/semantic/{}",
                    parameters: [
                        input.path.itemName,
                        input.path.semanticClass
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 404:
                    .notFound(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Remove unused/orphaned metadata.
    ///
    /// - Remark: HTTP `POST /items/metadata/purge`.
    /// - Remark: Generated from `#/paths//items/metadata/purge/post(purgeDatabase)`.
    public func purgeDatabase(_ input: Operations.purgeDatabase.Input) async throws -> Operations.purgeDatabase.Output {
        try await client.send(
            input: input,
            forOperation: Operations.purgeDatabase.id,
            serializer: { _ in
                let path = try converter.renderedPath(
                    template: "/items/metadata/purge",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Creates a sitemap event subscription.
    ///
    /// - Remark: HTTP `POST /sitemaps/events/subscribe`.
    /// - Remark: Generated from `#/paths//sitemaps/events/subscribe/post(createSitemapEventSubscription)`.
    public func createSitemapEventSubscription(_ input: Operations.createSitemapEventSubscription.Input) async throws -> Operations.createSitemapEventSubscription.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createSitemapEventSubscription.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/sitemaps/events/subscribe",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createSitemapEventSubscription.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.JerseyResponseBuilderDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 503:
                    return .serviceUnavailable(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Polls the data for one page of a sitemap.
    ///
    /// - Remark: HTTP `GET /sitemaps/{sitemapname}/{pageid}`.
    /// - Remark: Generated from `#/paths//sitemaps/{sitemapname}/{pageid}/get(pollDataForPage)`.
    public func pollDataForPage(_ input: Operations.pollDataForPage.Input) async throws -> Operations.pollDataForPage.Output {
        try await client.send(
            input: input,
            forOperation: Operations.pollDataForPage.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/sitemaps/{}/{}",
                    parameters: [
                        input.path.sitemapname,
                        input.path.pageid
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-Atmosphere-Transport",
                    value: input.headers.X_hyphen_Atmosphere_hyphen_Transport
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "subscriptionid",
                    value: input.query.subscriptionid
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeHidden",
                    value: input.query.includeHidden
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.pollDataForPage.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PageDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Polls the data for a whole sitemap. Not recommended due to potentially high traffic.
    ///
    /// - Remark: HTTP `GET /sitemaps/{sitemapname}/*`.
    /// - Remark: Generated from `#/paths//sitemaps/{sitemapname}/*/get(pollDataForSitemap)`.
    public func pollDataForSitemap(_ input: Operations.pollDataForSitemap.Input) async throws -> Operations.pollDataForSitemap.Output {
        try await client.send(
            input: input,
            forOperation: Operations.pollDataForSitemap.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/sitemaps/{}/*",
                    parameters: [
                        input.path.sitemapname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-Atmosphere-Transport",
                    value: input.headers.X_hyphen_Atmosphere_hyphen_Transport
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "subscriptionid",
                    value: input.query.subscriptionid
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeHidden",
                    value: input.query.includeHidden
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.pollDataForSitemap.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SitemapDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Get sitemap by name.
    ///
    /// - Remark: HTTP `GET /sitemaps/{sitemapname}`.
    /// - Remark: Generated from `#/paths//sitemaps/{sitemapname}/get(getSitemapByName)`.
    public func getSitemapByName(_ input: Operations.getSitemapByName.Input) async throws -> Operations.getSitemapByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSitemapByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/sitemaps/{}",
                    parameters: [
                        input.path.sitemapname
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "type",
                    value: input.query._type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "jsoncallback",
                    value: input.query.jsoncallback
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeHidden",
                    value: input.query.includeHidden
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSitemapByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SitemapDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Get sitemap events for a whole sitemap. Not recommended due to potentially high traffic.
    ///
    /// - Remark: HTTP `GET /sitemaps/events/{subscriptionid}/*`.
    /// - Remark: Generated from `#/paths//sitemaps/events/{subscriptionid}/*/get(getSitemapEvents)`.
    public func getSitemapEvents(_ input: Operations.getSitemapEvents.Input) async throws -> Operations.getSitemapEvents.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSitemapEvents.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/sitemaps/events/{}/*",
                    parameters: [
                        input.path.subscriptionid
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sitemap",
                    value: input.query.sitemap
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 400:
                    .badRequest(.init())
                case 404:
                    .notFound(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Get sitemap events.
    ///
    /// - Remark: HTTP `GET /sitemaps/events/{subscriptionid}`.
    /// - Remark: Generated from `#/paths//sitemaps/events/{subscriptionid}/get(getSitemapEvents_1)`.
    public func getSitemapEvents_1(_ input: Operations.getSitemapEvents_1.Input) async throws -> Operations.getSitemapEvents_1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSitemapEvents_1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/sitemaps/events/{}",
                    parameters: [
                        input.path.subscriptionid
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sitemap",
                    value: input.query.sitemap
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "pageid",
                    value: input.query.pageid
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSitemapEvents_1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/event-stream",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "text/event-stream":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .text_event_hyphen_stream(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SitemapWidgetEvent.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Get all available sitemaps.
    ///
    /// - Remark: HTTP `GET /sitemaps`.
    /// - Remark: Generated from `#/paths//sitemaps/get(getSitemaps)`.
    public func getSitemaps(_ input: Operations.getSitemaps.Input) async throws -> Operations.getSitemaps.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getSitemaps.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/sitemaps",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getSitemaps.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.SitemapDTO].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Get all registered UI components in the specified namespace.
    ///
    /// - Remark: HTTP `GET /ui/components/{namespace}`.
    /// - Remark: Generated from `#/paths//ui/components/{namespace}/get(getRegisteredUIComponentsInNamespace)`.
    public func getRegisteredUIComponentsInNamespace(_ input: Operations.getRegisteredUIComponentsInNamespace.Input) async throws -> Operations.getRegisteredUIComponentsInNamespace.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getRegisteredUIComponentsInNamespace.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ui/components/{}",
                    parameters: [
                        input.path.namespace
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "summary",
                    value: input.query.summary
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRegisteredUIComponentsInNamespace.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.RootUIComponent].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Add a UI component in the specified namespace.
    ///
    /// - Remark: HTTP `POST /ui/components/{namespace}`.
    /// - Remark: Generated from `#/paths//ui/components/{namespace}/post(addUIComponentToNamespace)`.
    public func addUIComponentToNamespace(_ input: Operations.addUIComponentToNamespace.Input) async throws -> Operations.addUIComponentToNamespace.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addUIComponentToNamespace.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ui/components/{}",
                    parameters: [
                        input.path.namespace
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case .none:
                    nil
                case let .json(value):
                    try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.addUIComponentToNamespace.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RootUIComponent.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Get a specific UI component in the specified namespace.
    ///
    /// - Remark: HTTP `GET /ui/components/{namespace}/{componentUID}`.
    /// - Remark: Generated from `#/paths//ui/components/{namespace}/{componentUID}/get(getUIComponentInNamespace)`.
    public func getUIComponentInNamespace(_ input: Operations.getUIComponentInNamespace.Input) async throws -> Operations.getUIComponentInNamespace.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUIComponentInNamespace.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ui/components/{}/{}",
                    parameters: [
                        input.path.namespace,
                        input.path.componentUID
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUIComponentInNamespace.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RootUIComponent.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Update a specific UI component in the specified namespace.
    ///
    /// - Remark: HTTP `PUT /ui/components/{namespace}/{componentUID}`.
    /// - Remark: Generated from `#/paths//ui/components/{namespace}/{componentUID}/put(updateUIComponentInNamespace)`.
    public func updateUIComponentInNamespace(_ input: Operations.updateUIComponentInNamespace.Input) async throws -> Operations.updateUIComponentInNamespace.Output {
        try await client.send(
            input: input,
            forOperation: Operations.updateUIComponentInNamespace.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ui/components/{}/{}",
                    parameters: [
                        input.path.namespace,
                        input.path.componentUID
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody? = switch input.body {
                case .none:
                    nil
                case let .json(value):
                    try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateUIComponentInNamespace.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RootUIComponent.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Remove a specific UI component in the specified namespace.
    ///
    /// - Remark: HTTP `DELETE /ui/components/{namespace}/{componentUID}`.
    /// - Remark: Generated from `#/paths//ui/components/{namespace}/{componentUID}/delete(removeUIComponentFromNamespace)`.
    public func removeUIComponentFromNamespace(_ input: Operations.removeUIComponentFromNamespace.Input) async throws -> Operations.removeUIComponentFromNamespace.Output {
        try await client.send(
            input: input,
            forOperation: Operations.removeUIComponentFromNamespace.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ui/components/{}/{}",
                    parameters: [
                        input.path.namespace,
                        input.path.componentUID
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    .ok(.init())
                case 404:
                    .notFound(.init())
                default:
                    .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }

    /// Get all registered UI tiles.
    ///
    /// - Remark: HTTP `GET /ui/tiles`.
    /// - Remark: Generated from `#/paths//ui/tiles/get(getUITiles)`.
    public func getUITiles(_ input: Operations.getUITiles.Input) async throws -> Operations.getUITiles.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getUITiles.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ui/tiles",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getUITiles.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.TileDTO].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
